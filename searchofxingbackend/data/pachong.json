{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1704124348211785729",
        "title": "网络编程,前端CRURD,服务器",
        "description": null,
        "content": "## 前端views开发简单CURD\n#### 根据原型设计图，完成前端页面的开发\n### 使用ElementUI完成页面的开发\n\n#### 1. 安装ElementUI\n```\nnpm i element-ui -S\n```\n#### 2. 在main.js中引入ElementUI\n```\nimport ElementUI from 'element-ui'\nimport 'element-ui/lib/theme-chalk/index.css'\nVue.use(ElementUI)\n```\n#### 3. 在App.vue中使用ElementUI\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>Main</el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n```\n#### 4. 使用ElementUI的组件 做出页面\n```\n<template>\n  <div id=\"app\">\n    <el-container>\n      <el-header>Header</el-header>\n      <el-main>\n        <el-table :data=\"tableData\">\n          <el-table-column prop=\"date\" label=\"日期\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"name\" label=\"姓名\" width=\"180\"></el-table-column>\n          <el-table-column prop=\"address\" label=\"地址\"></el-table-column>\n          <el-table-column label=\"操作\">\n            <template slot-scope=\"scope\">\n              <el-button type=\"primary\" size=\"mini\">编辑</el-button>\n              <el-button type=\"danger\" size=\"mini\">删除</el-button>\n            </template>\n          </el-table-column>\n        </el-table>\n      </el-main>\n      <el-footer>Footer</el-footer>\n    </el-container>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  data() {\n    return {\n      tableData: [{\n        date: '2016-05-02',\n        name: '王小虎',\n        address: '上海市普陀区金沙江路 1518 弄'\n      }, {\n        date: '2016-05-04',\n        name: '王小虎',\n        address: '上海市普陀区金沙江路 1517 弄'\n      }, {\n        date: '2016-05-01',\n        name: '王小虎',\n        address: '上海市普陀区金沙江路 1519 弄'\n      }, {\n        date: '2016-05-03',\n        name: '王小虎',\n        address: '上海市普陀区金沙江路 1516 弄'\n      }]\n    }\n  }\n}\n</script>\n```\n\n### 在钩子函数created中，向后端服务器发起请求,调用后台接口，获取数据\n\n### 接受后台返回的数据，渲染到页面上\n\n\n# 网络编程和服务器\n\n### B/S 和 C/S\n**C/S结构** ：全称为 Client/Server 结构，是指客户端和服务器结构。常见程序有 QQ ,百度网盘等软件。\n```markdown\nC/S结构的优点是：客户端可以直接使用服务器的资源，而不需要下载到本地，这样可以节省本地的资源。\nC/S结构的缺点是：客户端需要安装专门的客户端软件，而且客户端软件的更新也需要重新下载安装。\n```\n\n**B/S结构** ：全称为 Browser/Server 结构，是指浏览器和服务器结构。常见的浏览器有 Chrome ,IE ,Firefox 等。\n```markdown\nB/S结构的优点是：客户端不需要安装专门的客户端软件，只需要浏览器就可以访问服务器的资源。\nB/S结构的缺点是：客户端不能直接使用服务器的资源，需要通过浏览器来访问，这样会增加服务器的压力。\n```\n\n**新型 BS 结构** : 需求和技术发展的产物\n\n新型 BS 结构** : 需求和技术发展的产物\n```markdown\n瘦客户端 : 传统的 B/S .   服务端: 负责业务逻辑;   客户端: 负责界面渲染.\n富客户端 : 超级 BS=CS+BS , 界面华丽.  服务端:负责业务逻辑;   客户端: 负责界面渲染 + 少量的业务逻辑.\n```\n### 网络通信三要素\n```markdown\nIP地址: 用来标识网络中的一台计算机\n端口号: 用来标识计算机中的一个应用程序\n协议: 用来规定数据传输的规则\n```\n### UDP和TCP 协议\n```markdown\nUDP: 无连接的, 不可靠的, 速度快.\n\nTCP: 面向连接的, 可靠的, 速度慢.\n三次握手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 客户端向服务器发送确认.\n四次挥手: 1. 客户端向服务器发送请求. 2. 服务器向客户端发送响应. 3. 服务器向客户端发送确认. 4. 客户端向服务器发送确认.\n```\n### HTTPS 和 HTTP\n```markdown\nHTTPS: 安全的 HTTP 协议, 传输的数据是加密的.\nHTTP: 不安全的 HTTP 协议, 传输的数据是明文的.\n特点:\n1. **无状态：协议对客户端没有状态存储，对事务处理没有“记忆”能力。**\"\n\n2. HTTP/1.0，每次请求需要通过 TCP 三次握手建立连接，请求结束通过四次挥手断开连接，一次连接只能处理一个请求数据的传输。HTTP/1.1 一次连接成功之后可以处理·。\n\n3. 基于请求和响应：基本的特性，由客户端发起请求，服务端响应\n```\n\n## WEB 资源概述\n```markdown\n静态资源:服务器上的文件, 如: html, css, js, 图片, 视频, 音频等.\n动态资源: 服务器上的程序, 如: servlet, jsp, php, asp, py, rb, go, nodejs 等.\n```\n\n### 服务器软件\n#### 分类\n1. 静态服务器: 只能处理静态资源, 如: nginx, apache, tomcat 等.\n2. 动态服务器: 只能处理动态资源, 如: tomcat, nodejs 等.\n3. 静态+动态服务器: 可以处理静态资源和动态资源, 如: tomcat, nodejs 等.\n###   JavaEE 规范: 一套规范, 一套接口, 多种实现.\n- 在 JavaEE 中一共有 13 种规范。\n\n- 常见的 JavaEE 规范有： JSP、Servlet、JDBC、XML、EJB\n\n### Tomcat 安装和启动\n#### 下载\n\nTomcat 官网: http://tomcat.apache.org/\nTomcat 下载地址: http://tomcat.apache.org/download-80.cgi\n\n#### 安装\n\n1. 解压缩\n2. 配置环境变量, 如: JAVA_HOME, CATALINA_HOME 等.\n3. 修改配置文件,端口号.... 如: server.xml, web.xml 等.\n4. 启动,运行 bin 目录下的 startup.bat 文件.\n### Maven构建Tomcat 服务器\n#### 1. 创建 Maven 项目\n\ngroupId: 组织的唯一标识, 一般是公司的域名倒写.\nartifactId: 项目的唯一标识, 一般是项目的名称.\nversion: 项目的版本号, 一般是 1.0-SNAPSHOT.\n#### 2. 配置 \n1. 打包方式: war\n2. 依赖: tomcat7-maven-plugin和 tomcat-war-plugin\n3. 创建目录: src/main/webapp 和 src/main/webapp/WEB-INF 目录",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 8,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-19T13:24:40.000+00:00",
        "updateTime": "2023-09-20T02:17:28.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1703935396162957314",
        "title": "Vue-路由-生命周期-组件",
        "description": null,
        "content": "## Vue的生命周期\n\n#### 钩子函数\n\n**初始化阶段:**\n\n​\t\t1. **beforeCreate**：在实例被创建之前调用，此时实例的数据和方法都无法访问。\n\n​\t\t2. **created**：在实例被创建后立即调用，此时实例已经可以访问到数据和方法，但尚未完成挂载和渲染。\n\n**挂载阶段:**\n\n​\t\t1.**beforeMount**：在挂载开始之前调用，模板已经编译完成，但尚未将实例挂载到DOM上。\n​\t\t2.**mounted**：在挂载完成后调用，此时实例已经被挂载到DOM上，可以进行DOM操作和发送网络请求。\n\n**更新阶段:**\n\n​\t\t1.**beforeUpdate**：在数据更新之前调用，数据已经改变，但尚未更新到DOM上。\n​\t\t 2.**updated**：在数据更新后调用，此时数据已经更新到DOM上，可以对DOM进行操作。\n\n**销毁阶段:**\n\n1.**beforeDestroy**：在实例销毁之前调用，此时实例仍然可用，可以执行清理操作。\n\n2.**destroyed**：在实例销毁后调用，此时实例已经被销毁，无法再访问实例的数据和方法。\n\n**用途：**\n\n- beforeCreate和created常用于进行初始化操作，如数据的初始化、依赖的初始化等。\n\n- mounted常用于进行DOM操作、调用第三方库、发送异步请求等需要在实例挂载到DOM后执行的操作。\n\n- beforeUpdate和updated常用于对数据的响应式变化进行处理、更新DOM等操作。\n\n- beforeDestroy和destroyed常用于进行资源的释放、取消事件订阅、清理定时器等操作。\n\n- ```html\n  <template>\n    <div>\n      <h1>{{ message }}</h1>\n      <button @click=\"updateMessage\">Update Message</button>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    data() {\n      return {\n        message: 'Hello, Vue!',\n      };\n    },\n    beforeCreate() {\n      // 在组件实例被创建之前调用\n      console.log('beforeCreate');\n    },\n    created() {\n      // 在组件实例被创建后立即调用\n      // 此时已经完成了数据的初始化，可以访问 data 中的数据\n      console.log('created');\n    },\n    beforeMount() {\n      // 在组件挂载之前调用\n      // 此时模板编译已完成，但尚未将组件挂载到 DOM 中\n      console.log('beforeMount');\n    },\n    mounted() {\n      // 在组件挂载完成后调用\n      // 此时组件已被挂载到 DOM 中，可以进行 DOM 操作、发送异步请求等操作\n      console.log('mounted');\n    },\n    beforeUpdate() {\n      // 在组件更新之前调用\n      // 当组件的数据发生变化时会触发此钩子函数\n      // 可以在此阶段执行一些准备更新前的操作\n      console.log('beforeUpdate');\n    },\n    updated() {\n      // 在组件更新完成后调用\n      // 当组件的数据变化导致重新渲染完成后会触发此钩子函数\n      // 可以在此阶段执行一些依赖于更新后的 DOM 的操作\n      console.log('updated');\n    },\n    beforeDestroy() {\n      // 在组件销毁之前调用\n      // 可以在此阶段执行一些清理工作，如清除定时器、关闭网络连接等\n      console.log('beforeDestroy');\n    },\n    destroyed() {\n      // 在组件销毁之后调用\n      // 此时组件实例已被销毁，无法再访问组件实例的数据和方法\n      console.log('destroyed');\n    },\n    methods: {\n      updateMessage() {\n        this.message = 'Updated Message';\n      },\n    },\n  };\n  </script>\n  ```\n\n## Vue CLI 脚手架\n\n#### 安装 Vue CLI并创建一个项目\n\nVue CLI（Vue Command Line Interface）是一个用于快速构建基于 Vue.js 的项目的脚手架工具。通过使用 Vue CLI，我们可以快速搭建一个开箱即用的 Vue 项目，并获得一些便捷的开发工具和特性。\n\n要使用 Vue CLI，首先需要安装 Node.js，因为 Vue CLI 是通过 Node.js 运行的。\n\n安装完 Node.js 后，我们可以使用以下命令来全局安装 Vue CLI：\n\n```bash\nnpm install -g @vue/cli\n```\n\n安装完成后，我们可以使用 `vue create` 命令来创建新的 Vue 项目：\n\n```bash\nvue create my-project\n```\n\n在执行上述命令时，Vue CLI 会提示我们选择一种预设配置，例如默认配置、手动配置、Vue 3、TypeScript 等。根据需要选择相应的配置。\n\nVue CLI 会下载所需的模板和依赖包，并自动生成一个基本的 Vue 项目结构和配置文件。安装完成后，进入项目目录：\n\n```bash\ncd my-project\n```\n\n然后可以使用以下命令来启动项目：\n\n```bash\nnpm run serve\n```\n\n该命令会启动开发服务器，并在默认情况下将项目运行在 `http://localhost:8080` 上。此时，你可以在浏览器中访问该地址，查看运行中的 Vue 项目。\n\n除了创建新项目外，Vue CLI 还提供了许多其他命令和功能，例如添加插件、配置打包优化、运行测试等。你可以使用 `vue --help` 命令查看所有可用的命令和选项。\n\n#### 项目结构分析\n\n```\nmy-project/\n  |- build/                # 构建配置文件\n  |- config/               # 项目配置文件\n  |- node_modules/         # 项目依赖的所有模块\n  |- src/                  # 源代码文件夹\n    |- assets/             # 存放图像、样式等静态资源\n    |- components/         # 存放 Vue 组件\n    |- views/              # 存放页面级别的组件\n    |- App.vue             # 根组件\n    |- main.js             # 项目入口 JavaScript 文件\n  |- static/               # 存放静态资源\n  |- test/                 # 存放测试文件\n  |- .babelrc              # Babel 配置文件\n  |- .editorconfig         # 编辑器配置文件\n  |- .eslintignore         # ESLint 忽略文件配置\n  |- .eslintrc.js          # ESLint 配置文件\n  |- .gitignore            # Git 版本控制忽略文件配置\n  |- index.html            # 主页面 HTML 文件\n  |- package.json          # 项目依赖和脚本配置\n  |- README.md             # 项目说明文件\n```\n\n与前面提到的 Vue CLI 4.x 的项目结构相比，这里有一些不同之处：\n\n- `build/`：存放构建配置文件，如 webpack 配置等。\n\n- `config/`：存放项目配置文件，如端口配置等。\n\n- `static/`：存放静态资源，如图片、字体、样式表等。在 Vue CLI 2.x 中，静态资源是直接复制到构建输出目录中的，并不会经过 webpack 打包处理。\n\n- `test/`：存放测试文件，如单元测试和端到端测试相关的代码。\n\n- `.babelrc`：Babel 配置文件，用于配置 JavaScript 代码的转译规则。\n\n- `.editorconfig`：编辑器配置文件，用于统一不同编辑器的代码格式化规则。\n\n- `.eslintignore`：ESLint 忽略文件配置，用于指定哪些文件或文件夹应该被 ESLint 忽略检查。\n\n- `.eslintrc.js`：ESLint 配置文件，用于定义代码规范和检查规则。\n\n- `index.html`：主页面的 HTML 文件，在构建过程中会将打包后的代码嵌入到这个 HTML 文件中。。\n\n## 路由\n\n#### 什么是路由？\n\n在前端开发中，路由（Routing）是指确定在不同 URL（Uniform Resource Locator）路径下展示哪个页面或组件的过程。简单来说，路由就是根据 URL 的变化，决定显示哪个页面或组件给用户。\n\n- ~~~http\n  URL（Uniform Resource Locator）是统一资源定位符的缩写，是用于标识和定位互联网上资源（如网页、图片、视频等）的地址。\n  \n  一个标准的 URL 包含以下几个组成部分：\n  \n  1. 协议（Protocol）：URL 开头的部分，指定了访问资源所使用的协议，如 HTTP、HTTPS、FTP 等。\n  \n  2. 域名（Domain Name）：在协议之后，\":\" 符号之前的部分。域名是由一系列有层次结构的名称组成，比如 www.example.com，用于标识服务器的地址。\n  \n  3. 端口号（Port Number）：在域名之后，\":\" 符号之后的部分，可选。指定了服务器上的网络服务所使用的端口号，默认的端口号与各种协议相关，如 HTTP 是 80，HTTPS 是 443。\n  \n  4. 路径（Path）：在域名之后的 \"/\" 符号之后的部分，指定了服务器上资源的路径，用来定位具体的资源。\n  \n  5. 查询参数（Query Parameters）：在路径之后的 \"?\" 符号及其后的部分，用于向服务器传递额外的参数或信息，以便服务器根据这些参数来动态生成响应。\n  \n  6. 锚点（Fragment）：在路径之后的 \"#\" 符号及其后的部分，用于指定页面内的锚点，使页面滚动到指定的位置。\n  \n  举个例子，下面是一个 URL 的示例：\n  \n  ```\n  https://www.example.com:8080/path/to/resource?param1=value1&param2=value2#section-1\n  ```\n  \n  在这个示例 URL 中：\n  \n  - 协议为 HTTPS。\n  - 域名为 www.example.com。\n  - 端口号为 8080。\n  - 路径为 /path/to/resource。\n  - 查询参数为 param1=value1 和 param2=value2。\n  - 锚点为 section-1。\n  \n  通过 URL，我们可以唯一地定位和访问互联网上的各种资源。在浏览器中输入 URL，浏览器会解析 URL 并向对应的服务器发送请求，服务器接收请求并返回相应的资源，最终浏览器会将资源渲染并显示给用户。\n  ~~~\n\n在传统的多页面应用中，用户通过点击链接或提交表单来跳转到不同的页面。每个页面都需要向服务器发送请求，服务器返回相应的 HTML、CSS 和 JavaScript，重新渲染整个页面。这种方式在用户体验和性能上有一定的局限性。\n\n而在单页应用（SPA，Single Page Application）中，网站或应用的所有页面都加载一次，然后通过 JavaScript 动态地在前端进行内容的切换和更新。这种情况下，就需要使用路由来管理 URL 和对应的页面或组件之间的关系。\n\n在前端框架（如 Vue.js、React、Angular）中，通常都有自己的路由机制，用于管理应用的不同页面或组件之间的切换。通过路由，我们可以定义各个 URL 路径所对应的组件，并在用户访问到相应的 URL 时，动态地加载和显示对应的组件。\n\n路由系统通常提供了以下核心功能：\n\n1. **定义路由规则**：我们可以配置不同的 URL 路径和对应的组件之间的关系，即定义路由规则。可以使用精确匹配或模糊匹配来实现不同的页面展示逻辑。\n\n2. **路由导航**：可以通过编程方式或用户的交互跳转到不同的页面，路由系统会根据规则加载对应的组件并显示。\n\n3. **参数传递：**路由可以支持在 URL 中传递参数，用于动态地向组件传递数据，以便定制不同的展示内容。\n\n4. **嵌套路由**：路由系统通常还支持嵌套路由，即在一个页面中嵌套加载其他子页面或组件，使页面结构更加灵活和可维护。\n\n总结来说，路由是在前端应用中用于管理 URL 和对应页面或组件之间关系的机制。它使得单页应用可以更加灵活地根据 URL 的变化来切换页面内容，提供了更佳的用户体验和性能。\n\n前端路由和后端路由是在前端和后端开发中用于管理 URL 和对应处理程序之间关系的概念。\n\n#### **前端路由**（Front-end Routing）：\n\n在前端开发中，前端路由是通过 JavaScript 在客户端实现的，用于管理单页应用（SPA）中不同 URL 路径与对应页面或组件之间的关系。前端路由通过监听 URL 的变化，根据配置的路由规则动态加载和显示对应的页面或组件，实现页面间的无刷新切换。\n\n常见的前端路由库或框架有 Vue Router（用于 Vue.js），React Router（用于 React），Angular Router（用于 Angular），它们提供了路由规则的定义、路由导航、参数传递等功能，使得构建交互式前端应用变得更加方便和灵活。\n\n#### **后端路由**（Back-end Routing）：\n\n在后端开发中，后端路由是通过服务器端实现的，用于处理不同 URL 路径的请求并返回相应的响应数据。后端路由通过监听客户端发来的 HTTP 请求，根据请求的 URL 路径和其他条件，将请求转发给相应的处理程序（如控制器或处理函数），然后处理程序返回相应的数据或页面。\n\n不同的后端框架或语言都有自己的后端路由机制，如 Express.js（基于 Node.js 的框架）、Django（Python 的框架）等。这些框架提供了定义路由规则、路由注册、参数解析等功能，使得后端开发人员可以方便地构建和管理多个不同 URL 路径的响应逻辑。\n\n总结来说，前端路由用于在前端应用中管理不同 URL 路径和对应页面或组件之间的关系，而后端路由用于在后端处理不同 URL 路径的请求并返回相应的响应数据。两者一起工作，使得前后端的交互更加灵活和可靠。\n\n#### Vue-router 基本使用\n\nVue Router 是 Vue.js 官方提供的路由管理器，用于在 Vue 应用中实现前端路由。下面是 Vue Router 的基本使用步骤：\n\n1. 安装 Vue Router：在终端中执行以下命令来安装 Vue Router 包：\n```bash\nnpm install vue-router\n```\n\n2. 引入 Vue Router：在项目的入口文件（例如 `main.js`）中引入 Vue Router，并使用 Vue.use() 来注册它：\n```javascript\nimport Vue from 'vue';\nimport VueRouter from 'vue-router';\n\nVue.use(VueRouter);\n```\n\n3. 设置路由的组件：在项目中的某个组件中定义要作为路由的组件（例如 `Home.vue` 和 `About.vue`）。\n\n4. 配置路由规则：在入口文件中定义路由规则，并创建一个 VueRouter 实例：\n```javascript\nconst router = new VueRouter({\n  routes: [\n    { path: '/', component: Home },\n    { path: '/about', component: About }\n  ]\n});\n```\n这里的 `routes` 数组中的每个对象表示一个路由规则，`path` 表示 URL 路径，`component` 表示对应的组件。\n\n5. 将路由挂载到 Vue 实例上：将创建的 router 实例传递给 Vue 实例的 `router` 选项：\n```javascript\nnew Vue({\n  router\n}).$mount('#app');\n```\n\n6. 显示路由视图：在 Vue 模板中使用 `<router-view>` 组件来显示对应的路由组件。在模板中可以使用 `<router-link>` 组件来创建跳转到不同路由的链接：\n```html\n<router-link to=\"/\">Home</router-link>\n<router-link to=\"/about\">About</router-link>\n\n<router-view></router-view>\n```\n\n##### 懒加载\n\n懒加载（Lazy Loading），也称为按需加载，是一种优化技术，用于在需要时动态地加载资源，而不是一次性加载所有资源。\n\n在前端开发中，懒加载主要用于优化页面加载速度和减少初始资源的大小。当页面较大或包含大量的资源（如图片、视频、JavaScript 文件等）时，一次性加载所有资源可能会导致首次加载时间过长，用户体验不佳。\n\n通过懒加载，可以将页面划分为多个片段或模块，并只在用户需要时加载特定的模块。当用户滚动页面到达某个区域、点击某个按钮或触发其他交互事件时，才会动态地加载对应的模块。这样可以将页面的初始加载时间缩短，并在用户需要时进行资源加载，提高页面的响应速度。\n\n在实现懒加载时，常见的方式有以下几种：\n\n1. 图片懒加载：对于页面中的图片，可以将图片的实际 URL 放置在自定义的属性（例如 `data-src`）中，而不是 `src` 属性中。当图片进入用户可视区域时，再将 `data-src` 中的 URL 赋值给 `src` 属性，触发图片的实际加载。\n\n2. 路由懒加载：对于前端路由中的组件，可以使用动态 `import()` 或 `require.ensure`（在旧版 webpack 中使用）语法来按需加载组件。例如，在 Vue Router 中，可以将路由组件的配置修改为类似于下面的形式：\n```javascript\n{ path: '/about', component: () => import('./About.vue') }\n```\n这样，在用户访问 `/about` 路径时，才会动态地加载 `About.vue` 组件。\n\n3. 模块懒加载：对于其他模块或资源，例如 JavaScript 文件或第三方库，可以使用动态加载的方式，通过异步加载脚本来按需加载。例如，可以使用动态创建 `<script>` 标签或使用模块加载器（如 require.js、System.js）来动态加载 JavaScript 文件。\n\n##### 路由模式\n\n在 Vue Router 中，有两种常见的路由模式：**哈希模式**（Hash Mode）和**历史模式**（History Mode）。\n\n1. **哈希模式（Hash Mode）**：这是 Vue Router 的默认路由模式。在哈希模式下，URL 中的路由路径会以 `#` 符号开始，例如 `http://example.com/#/home`。哈希符号之后的部分被称为**哈希值**。当 URL 中的哈希值发生变化时，不会触发页面的重新加载，而是通过 JavaScript 监听 `hashchange` 事件来实现页面的切换。哈希模式可以保证路由的兼容性，因为即使在不支持 HTML5 History API 的浏览器中，也可以正常使用路由功能。\n\n2. **历史模式（History Mode）**：在历史模式下，URL 中的路由路径是正常的 URL，不包含哈希符号。例如 `http://example.com/home`。在历史模式下， Vue Router 使用 HTML5 的 History API 来管理路由，通过修改浏览器的历史记录来实现页面的切换。在支持 History API 的现代浏览器中，可以使用 `pushState` 和 `replaceState` 方法来修改 URL，而不会触发页面的刷新。历史模式提供了更加优雅的 URL，但要注意在使用历史模式时，需要服务器端的配置支持，以防止刷新页面时出现 404 错误。\n\n可以通过在创建 VueRouter 实例时传递 `mode` 选项来设置路由模式，例如：\n```javascript\nconst router = new VueRouter({\n  mode: 'history',\n  routes: [...]\n});\n```\n\n其中，`mode` 的值可以是 `'hash'`（哈希模式）或 `'history'`（历史模式）。\n\n在选择路由模式时，需要考虑项目的部署环境和对 URL 的需求。如果项目是一个单页面应用，并且不需要关注 URL 的格式或搜索引擎优化（SEO），则可以使用默认的哈希模式。如果希望 URL 更加友好，并且需要支持刷新页面时的路由匹配，可以考虑使用历史模式，但需要在服务器端进行相应的配置支持。\n\n##### 路由跳转方式\n\n在 Vue Router 中，可以使用多种方式进行路由跳转，以下是常用的几种方式：\n\n1. **命令式导航（Imperative Navigation）**：通过编程方式来触发路由跳转，通常在组件中使用 `$router` 实例来调用相应的方法。例如：\n```javascript\n// 在组件中使用 this.$router.push() 进行路由跳转\nthis.$router.push('/home'); // 跳转到 /home\n\n// 或者使用 this.$router.replace() 替换当前路由\nthis.$router.replace('/about'); // 替换当前路由为 /about\n\n// 或使用 this.$router.go() 函数进行前进或后退\nthis.$router.go(-1); // 后退一页\n```\n\n2. **声明式导航（Declarative Navigation）**：通过在模板中使用 `<router-link>` 组件或 `router.push()` 方法来进行路由跳转，可以直接在模板中设置对应的路由链接。例如：\n```html\n<!-- 在模板中使用 <router-link> 组件 -->\n<router-link to=\"/home\">Home</router-link>\n<router-link :to=\"{ path: '/about' }\">About</router-link>\n\n<!-- 或通过 $router.push() 进行路由跳转 -->\n<button @click=\"$router.push('/home')\">Go Home</button>\n```\n\n3. **编程式导航（Programmatic Navigation）**：通过在 JavaScript 代码中手动创建路由跳转的对象，然后将其传递给 `$router.push()` 或 `$router.replace()` 方法。例如：\n```javascript\nconst routeOptions = {\n  path: '/home',\n  query: { key: 'value' },\n  params: { id: 1 }\n};\n\n// 使用 $router.push() 实现编程式导航\nthis.$router.push(routeOptions);\n```\n这里的 `routeOptions` 是一个包含路由跳转参数的对象，可以设置 `path`、`query`（查询参数）和 `params`（路径参数），用于传递给目标路由。\n\n无论是何种方式进行路由跳转，Vue Router 都会根据路由配置自动映射到对应的组件，并渲染到 `<router-view>` 中显示。可以根据应用的实际需求选择合适的方式进行路由跳转，以实现页面的导航和交互。\n\n##### 编程式跳转\n\n编程式跳转是通过在 JavaScript 代码中手动创建路由跳转的对象，然后使用 `$router.push()` 或 `$router.replace()` 方法来实现路由的跳转。以下是编程式跳转的示例：\n\n1. 使用 `$router.push()` 进行编程式跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push('/home');  // 跳转到 /home 路由\n\n// 传递参数的跳转\nthis.$router.push({ path: '/about', query: { id: 1 } });  // 跳转到 /about?id=1 路由\n\n// 命名路由的跳转\nthis.$router.push({ name: 'user', params: { id: 1 } });  // 跳转到命名为 'user'，带有参数 id 的路由\n```\n\n2. 使用 `$router.replace()` 进行编程式跳转，与 `$router.push()` 类似，但会替换当前路由而不是添加新路由到历史记录：\n```javascript\nthis.$router.replace('/home');  // 替换当前路由为 /home\n\n// 传递参数的跳转\nthis.$router.replace({ path: '/about', query: { id: 1 } });  // 替换当前路由为 /about?id=1\n\n// 命名路由的跳转\nthis.$router.replace({ name: 'user', params: { id: 1 } });  // 替换当前路由为命名为 'user'，带有参数 id 的路由\n```\n\n在编程式跳转时，可以直接传递目标路由的路径字符串，也可以传递包含路由配置的对象。对象参数中可以设置的选项包括：`path`（路径）、`query`（查询参数）、`params`（路径参数）以及 `name`（命名路由）等。\n\n需要注意的是，可以在组件中使用 `$router` 对象来调用 `$router.push()` 或 `$router.replace()` 方法，但在普通的 JavaScript 代码中，必须通过 Vue 实例来访问 `$router` 对象，例如 `this.$router.push()`。\n\n##### 路由命名\n\n在 Vue Router 中，可以为路由配置指定名称（Name），以便在编程式路由跳转、路由链接生成等场景中使用。通过为路由定义名称，可以避免直接使用路径字符串，使代码更加清晰可读。以下是在 Vue Router 中进行路由命名的示例：\n\n在路由配置中，可以使用 `name` 属性为路由指定名称：\n```javascript\nconst routes = [\n  {\n    path: '/home',\n    name: 'home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: About\n  },\n  // ...\n];\n```\n\n定义了名称之后，可以在组件中或任意 JavaScript 代码中使用路由名称进行编程式路由跳转：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ name: 'home' });  // 跳转到名称为 'home' 的路由\n\n// 传递参数的跳转\nthis.$router.push({ name: 'about', query: { id: 1 } });  // 跳转到名称为 'about' 的路由，并传递查询参数 id\n```\n\n在编程式跳转时，可以使用 `{ name: 'routeName' }` 的形式指定路由名称，从而跳转到对应的路由路径。可以是使用 `push()` 方法进行正常的路由跳转，也可以使用 `replace()` 方法进行路由替换。\n\n此外，还可以在模板中使用 `<router-link>` 组件来生成具有路由名称的链接：\n```html\n<router-link :to=\"{ name: 'home' }\">Home</router-link>\n<router-link :to=\"{ name: 'about' }\">About</router-link>\n```\n\n通过 `<router-link>` 组件的 `to` 属性指定路由名称，即可生成对应的路由链接。\n\n##### query 传参\n\n在 Vue Router 中，可以使用查询参数（Query Parameters）来传递参数。查询参数是附加在 URL 后面的键值对形式，例如 `http://example.com/path?param1=value1&param2=value2`。\n\n以下是在 Vue Router 中使用查询参数传参的示例：\n\n1. **编程式导航传递查询参数**：\n```javascript\n// 在组件中或任意 JavaScript 代码中\nthis.$router.push({ path: '/path', query: { param1: 'value1', param2: 'value2' } });\n```\n上述代码将导航到 `/path` 路由，并传递了两个查询参数 `param1` 和 `param2`。生成的 URL 将类似于 `http://example.com/path?param1=value1&param2=value2`。\n\n2. **路由链接传递查询参数**：\n```html\n<router-link :to=\"{ path: '/path', query: { param1: 'value1', param2: 'value2' } }\">Go Path</router-link>\n```\n上述代码将生成一个带有查询参数的路由链接。点击链接时，将导航到 `/path` 路由，并传递了查询参数 `param1` 和 `param2`。\n\n3. **获取查询参数：**\n可以在组件中使用 `$route.query` 来获取当前路由的查询参数：\n```javascript\n// 在组件中使用\nconsole.log(this.$route.query.param1);  // 输出查询参数 param1 的值\nconsole.log(this.$route.query.param2);  // 输出查询参数 param2 的值\n```\n\n查询参数的值将会自动进行类型转换，默认情况下，它们会被解析为字符串。如果传递的值是数字，可以在取值时使用 `parseInt()` 或其他转换方法将其转换为数字类型。例如：\n```javascript\nconst param1Value = parseInt(this.$route.query.param1);\n```\n\n需要注意的是，查询参数是可选的，因此可以在某些情况下省略它们。\n\n在路由路径中使用查询参数可以方便地传递一些额外的信息，如搜索关键字、页码等。通过在导航时传递查询参数，可以使应用程序更加灵活和可配置。\n\n##### 路由重定向\n\n在 Vue Router 中，可以使用路由重定向（Redirect）来将某个路径重定向到另一个路径。路由重定向可以用于在用户访问某个路径时，自动将其导航到另一个路径，或者用于配置默认路由。\n\n以下是在 Vue Router 中进行路由重定向的几种方式：\n\n1. **通过路由配置进行重定向：**\n在路由配置中，可以使用 `redirect` 属性指定重定向的路径：\n```javascript\nconst routes = [\n  {\n    path: '/',\n    redirect: '/home'\n  },\n  {\n    path: '/home',\n    component: Home\n  },\n  {\n    path: '/about',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到 `/home` 路径。这意味着当用户访问根路径时，会自动重定向到 `/home`。\n\n2. **通过命名路由进行重定向：**\n如果使用了命名路由，还可以通过命名路由进行重定向。在路由配置中，通过 `name` 属性为路由指定名称，然后在重定向中使用该名称：\n```javascript\nconst routes = [\n  {\n    path: '/',\n    redirect: { name: 'home' }\n  },\n  {\n    path: '/home',\n    name: 'home',\n    component: Home\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: About\n  },\n  // ...\n];\n```\n上述代码中，配置了根路径 `/` 的重定向到名称为 `home` 的路由。用户访问根路径时，会自动重定向到名称为 `home` 的路由路径。\n\n3. **动态重定向：**\n有时，可能需要根据特定条件来动态进行路由重定向。可以使用动态路由的方式来实现。在路由配置中，可以通过 `redirect` 属性的值为一个函数，进行动态重定向的逻辑处理：\n```javascript\nconst routes = [\n  {\n    path: '/product/:id',\n    redirect: to => {\n      const { id } = to.params;\n      if (id === '1') {\n        return '/product-a';  // 重定向到 /product-a\n      } else {\n        return '/product-b';  // 重定向到 /product-b\n      }\n    }\n  },\n  // ...\n];\n```\n上述代码中，动态路由 `/product/:id` 根据参数 `id` 进行重定向处理，根据不同的 `id` 值，重定向到不同的路径。\n\n通过路由重定向，可以将一个路径重定向到另一个路径，使应用程序具有更好的导航和用户体验。可以根据应用需求选择适合的方式来配置路由重定向。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 7,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-19T00:53:50.000+00:00",
        "updateTime": "2023-09-20T02:15:12.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1703594490700361729",
        "title": "MySQL常见的性能优化方法技巧以及示例",
        "description": "MySQL常见的性能优化方法介绍，为什么能实现优化，具体代码示例",
        "content": "MySQL是一种广泛用于管理和存储数据的关系型数据库管理系统。在处理大规模数据和高并发请求时，MySQL的性能优化变得尤为重要。本文将介绍一些常见的MySQL性能优化方法和技巧，以及相应的示例，帮助我们提升数据库系统的性能。\n\n## 1. 使用合适的数据类型\n\n**方法：** 选择合适的数据类型来存储数据，以节省存储空间和提高查询速度。\n\n**原因：** 错误的数据类型选择可能导致存储空间浪费和查询性能下降。\n\n**示例：** 如果需要存储一个小整数，使用`TINYINT`而不是`INT`来节省存储空间：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    age TINYINT\n);\n```\n\n## 2. 创建索引\n\n**方法：** 为经常用于过滤和排序的列创建索引。\n\n**原因：** 索引可以显著提高查询性能，减少数据检索时间。\n\n**示例：** 创建一个名为`email_index`的索引来加速根据电子邮件查找用户的查询：\n\n```sql\nCREATE INDEX email_index ON users (email);\n```\n\n## 3. 使用合适的查询语句\n\n**方法：** 编写高效的查询语句，避免不必要的复杂性。\n\n**原因：** 不良的查询语句可能导致性能下降和资源浪费。\n\n**示例：** 优化查询，只选择需要的列，避免使用`SELECT *`：\n\n```sql\nSELECT user_id, username FROM users WHERE age > 25;\n```\n\n## 4. 调整服务器参数\n\n**方法：** 根据数据库负载和硬件性能，调整MySQL服务器的配置参数。\n\n**原因：** 适当的配置可以提高数据库的整体性能。\n\n**示例：** 增加`innodb_buffer_pool_size`以提高缓存效率：\n\n```sql\nSET GLOBAL innodb_buffer_pool_size = 4G;\n```\n\n## 5. 分表分区\n\n**方法：** 当数据表非常大时，考虑将其分成更小的表或分区，以减轻查询压力。\n\n**原因：** 分表分区可以加速查询，降低锁竞争。\n\n**示例：** 根据用户注册日期将用户表分成月份分区：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    registration_date DATE\n) PARTITION BY RANGE (YEAR(registration_date)) (\n    PARTITION p1 VALUES LESS THAN (2000),\n    PARTITION p2 VALUES LESS THAN (2001),\n    PARTITION p3 VALUES LESS THAN (2002),\n    ...\n);\n```\n\n\n## 6. 数据库规范化\n\n**方法：** 使用数据库规范化将数据分解成多个关联表，避免数据冗余。\n\n**原因：** 规范化有助于减少存储空间和数据更新成本，并提高数据一致性。\n\n**示例：** 将用户信息和地址信息分为两个表，通过外键关联：\n\n```sql\nCREATE TABLE users (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    address_id INT\n);\n\nCREATE TABLE addresses (\n    address_id INT AUTO_INCREMENT PRIMARY KEY,\n    street VARCHAR(255),\n    city VARCHAR(255),\n    state VARCHAR(255),\n    zip_code VARCHAR(10)\n);\n```\n\n## 7. 使用连接池\n\n**方法：** 在应用程序中使用连接池，以便有效地管理数据库连接。\n\n**原因：** 连接池可以减少每次请求时创建和销毁连接的开销，提高性能。\n\n**示例：** 在Java中使用HikariCP连接池：\n\n```java\nHikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(\"jdbc:mysql://localhost/mydb\");\nconfig.setUsername(\"user\");\nconfig.setPassword(\"password\");\n\nHikariDataSource dataSource = new HikariDataSource(config);\n```\n\n## 8. 使用存储过程\n\n**方法：** 将一系列SQL语句封装在存储过程中，减少网络延迟和SQL解析时间。\n\n**原因：** 存储过程可以提高多次执行相同操作的效率。\n\n**示例：** 创建一个简单的存储过程来插入用户记录：\n\n```sql\nDELIMITER //\nCREATE PROCEDURE InsertUser(username VARCHAR(255))\nBEGIN\n    INSERT INTO users (username) VALUES (username);\nEND //\nDELIMITER ;\n```\n\n## 9. 监控和调优工具\n\n**方法：** 使用监控工具如MySQL性能监控器、slow query日志和Percona Toolkit来识别性能问题。\n\n**原因：** 监控工具可以帮助您及时发现和解决性能瓶颈。\n\n**示例：** 启用slow query日志以捕获执行时间较长的查询：\n\n```sql\nSET GLOBAL slow_query_log = ON;\nSET GLOBAL long_query_time = 1; -- 设置慢查询的时间阈值（单位：秒）\n```\n\n## 10. 垂直分区\n\n**方法：** 将表按列进行垂直分区，将经常访问的列存储在单独的表中。\n\n**原因：** 垂直分区可以提高查询性能，减少磁盘I/O。\n\n**示例：** 将用户表中的基本信息和详细信息分开存储：\n\n```sql\nCREATE TABLE user_basic (\n    user_id INT AUTO_INCREMENT PRIMARY KEY,\n    username VARCHAR(255),\n    email VARCHAR(255)\n);\n\nCREATE TABLE user_details (\n    user_id INT PRIMARY KEY,\n    age INT,\n    address VARCHAR(255)\n);\n```\n\n综上所述，MySQL性能优化是一个广泛的领域，有许多方法可以使用，具体取决于您的应用需求和数据库结构。通过合理选择和实施这些方法，您可以提高MySQL数据库的性能，确保它能够高效地处理数据并提供卓越的用户体验。\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 13,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1609742938097582081",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-18T02:19:12.000+00:00",
        "updateTime": "2023-09-20T02:15:15.000+00:00",
        "user": {
          "id": "1609742938097582081",
          "planetCode": "958",
          "userName": "小马",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/9R5BLk13SjL1BEZoVjChNibGaTlfqxBeHt16B4OicOicriaDb5Gke5jCOl92vwBKsGYjKUsHmWv25K6h4oeTZhRxiaw/132",
          "gender": 1,
          "userProfile": "享受",
          "userRole": "vip",
          "interests": [
            "后端",
            "算法",
            "笔记"
          ],
          "place": null,
          "birthday": "2001-10-10",
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2024,
          "jobStatus": "求职中",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 20,
          "coin": 220,
          "followeeNum": 1,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-02-02T23:52:00.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-02T02:46:38.000+00:00",
          "updateTime": "2023-09-18T13:08:17.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1703014128530092034",
        "title": "JavaScript-Vue",
        "description": null,
        "content": "# 前端视图开发:\n\nhtml 标签 +css 样式 + js 交互\n\n### 前端给后端传数据:注册页面\n\n1. 用户在表单中修改数据(修改视图 View)\n2. 视图改变后,会同时改变js中的数据 (修改Model模型)\n3. 直接将js中的数据传给后端 (修改Controller控制器)\n\n### 前端展示后端数据:学生列表\n\n1. 将后端的数据传入到js data中(修改Model模型)\n2. 前端页面上有一个空的表格来获取data中的数据(修改视图View)\n\n# Vue 入门总结\n\n## 1. Vue的基本使用\n\n### 1.1 Vue的基本使用\n\n1. 引入vue.js文件\n2. 创建Vue实例\n3. 挂载到某个元素上\n4. 使用Vue的语法\n5. 使用Vue的指令\n\n### 1.2 Vue的指令\n\n1. 插值表达式: `{{}} 替换文本内容`\n\n2. v-bind: 单项数据绑定 v-bind:属性名=\"数据\"\n    ```html\n    <div id=\"app\">\n        <img v-bind:src=\"imgUrl\" alt=\"\">\n    </div>\n    \n    <script>\n        let app = new Vue({\n            el: '#app',\n            data: {\n                imgUrl: 'https://www.baidu.com/img/bd_logo1.png'\n            }\n        })\n    </script>\n    ```\n3. v-on: 事件绑定 v-on:事件名=\"函数名\"\n    ```html\n    <div id=\"app\">\n        <button v-on:click=\"btnClick\">按钮</button>\n    </div>\n    \n    <script>\n        let app = new Vue({\n            el: '#app',\n            data: {\n                imgUrl: 'https://www.baidu.com/img/bd_logo1.png'\n            },\n            methods: {\n                btnClick: function () {\n                    console.log('按钮被点击了')\n                }\n            }\n        })\n    </script>\n    ```\n4. v-if 和 v-show 的区别\n    - v-if: 控制元素的显示和隐藏, 如果为false, 元素会被移除\n    - v-show: 控制元素的显示和隐藏, 如果为false, 元素会被隐藏\n\n```html\n    <div id=\"app\">\n        <button v-on:click=\"btnClick\">按钮</button>\n        <div v-if=\"isShow\">显示</div>\n        <div v-show=\"isShow\">显示</div>\n    </div>\n    \n    <script>\n        let app = new Vue({\n            el: '#app',\n            data: {\n                isShow: true\n            },\n            methods: {\n                btnClick: function () {\n                    this.isShow = !this.isShow\n                }\n            }\n        })\n    </script>\n    ```\n5. v-for: 循环遍历\n    ```html\n    <div id=\"app\">\n        <ul>\n            <li v-for=\"item in list\">{{item}}</li>\n        </ul>\n        \n        <table>\n            <tr>\n                <th>姓名</th>\n                <th>年龄</th>\n            </tr>\n            <tr v-for=\"stu in students\">\n<!--            <td>{{stu.name}}</td>-->\n<!--            <td>{{stu.age}}</td>-->\n            <td v-for=\"value in stu\">{{value}}</td>\n<!--            <td v-for=\"(value,key,index) in stu\">{{value}}</td>-->\n        </tr>\n            \n        </table>\n    </div>\n\n    <script>\n        let app = new Vue({\n            el: '#app',\n            data: {\n                list: ['a', 'b', 'c'],\n                students: [\n                    {name: '张三', age: 18},\n                    {name: '李四', age: 19},\n                    {name: '王五', age: 20},\n                ]\n            }\n        })\n    </script>\n    ```\n6. v-model: 双向数据绑定\n    ```html\n    <div id=\"app\">\n        <input type=\"text\" v-model=\"message\">\n        <p>{{message}}</p>\n    </div>\n\n    <script>\n        let app = new Vue({\n            el: '#app',\n            data: {\n                message: 'hello world'\n            }\n        })\n    </script>\n    ```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 23,
        "thumbNum": 2,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-16T11:53:03.000+00:00",
        "updateTime": "2023-09-19T01:00:10.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章",
          "Vue",
          "NodeJS"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1702692506019426306",
        "title": "Node.js",
        "description": "初步认识 Node.js",
        "content": "# Node.js\n##使用步骤\n##### nvm Node管理器\n`nvm`：`node` 版本管理器，也就是说：一个 `nvm` 可以管理多个 `node` 版本（包含 `npm` 与 `npx`），可以方便快捷的 安装、切换 不同版本的 `node`。\n可以在配置文件中中更改淘宝镜像地址: `nvm node_mirror 镜像地址`\n##### 安装Node\n`node`：是一个基于 `Chrome V8` 引擎的 `JS` 运行环境。\n语法`nvm install 版本号`\n\n### 安装CNPM,Yarn,PnPm\n`cnpm`：是 `npm` 的淘宝镜像，可以方便快捷的安装 `npm` 包。\n`yarn`：是 `Facebook` 推出的新一代包管理工具，可以方便快捷的安装 `npm` 包。\n`pnpm`：是 `npm` 的增强版，可以方便快捷的安装 `npm` 包。\n语法`npm install -g cnpm --registry=https://registry.npm.taobao.org`\n语法`npm install -g yarn`\n语法`npm install -g pnpm`\n## 模块化\n#### 为什么要模块化\n- 请求过多（页面复杂度高，依赖的文件多因此请求也就增加了）\n- 依赖模糊（当依赖文件过多时，很难去分辨到底谁依赖了谁）\n- 命名空间污染（一个 js 文件被引入以后，其中所有变量/函数都可以被外部访问，多个文件相同的变量/函数名会冲突）\n- 由于以上的一系列原因会导致维护性变得非常差，因此我们需要模块化来解决这些问题。\n### CommonJS\n```html\n<script>\n  // 暴露模块\n  module.exports = value\n  exports.xxx = value\n  // 引入模块\n  var module = require(模块名或模块路径)\n</script>\n```\n\n### ES6 模块化\n```html\n<script type=\"module\">\n  // 暴露模块\n  export var xxx = value\n  export function xxx(){}\n  export default value\n  // 引入模块\n  import * as module from '模块名或模块路径'\n  import {xxx, yyy as alias} from '模块名或模块路径'\n  import value from '模块名或模块路径'\n</script>\n```\n\n\n## Webpack\n### 安装\n语法`npm install webpack webpack-cli -g`\n### 打包模块js 文件\n语法`webpack ./src/main.js -o ./dist/bundle.js --mode=development`\n### webpack.config.js\n```js\nconst path = require('path')\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n    publicPath: 'dist/'\n  },\n  mode: 'development'\n}\n```\n\n\n\n\n\n\n### 热部署\n安装依赖包`npm install webpack-dev-server -D`\n修改配置文件\n```html\n\"scripts\": {\n    \"build\": \"webpack-dev-server --config webpack.config.js --open --port 3000 --hot\"\n}\n\n- --open 自动打开浏览器\n- --port 服务监听的端口 3000\n- --hot  文件变动后自动更新\n```\n语法`npm install webpack-dev-server -g`\n\n#### html-webpack-plugin 插件\n安装依赖包`npm install html-webpack-plugin -D`\n修改配置文件\n```js\nconst path = require('path')\nconst htmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n    // publicPath: 'dist/'\n  },\n  mode: 'development',\n  plugins: [\n    new htmlWebpackPlugin({\n      template: 'index.html'\n    })\n  ]\n}\n```\n### css-loader\n安装依赖包`npm install css-loader -D`\n安装依赖包`npm install style-loader -D`\n修改配置文件\n```js\nconst path = require('path')\nconst htmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n    // publicPath: 'dist/'\n  },\n  mode: 'development',\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      }\n    ]\n  },\n  plugins: [\n    new htmlWebpackPlugin({\n      template: 'index.html'\n    })\n  ]\n}\n```\n\n\n### 将js Es6语法文件转ES5语法\n```html\ncnpm install babel-core babel-loader@7.1.5 babel-plugin-transform-runtime@6.23.0 babel-preset-env@1.7.0 babel-preset-stage-0@6.24.1 -D\n```\n\n修改配置文件\n```js\nconst path = require('path')\nconst htmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    path: path.resolve(__dirname, './dist'),\n    filename: 'bundle.js',\n    // publicPath: 'dist/'\n  },\n  mode: 'development',\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'css-loader']\n      },\n      {\n        test: /\\.js$/,\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['env'],\n            plugins: ['transform-runtime']\n          }\n        }\n      }\n    ]\n  },\n  plugins: [\n    new htmlWebpackPlugin({\n      template: 'index.html'\n    })\n  ]\n}\n```",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 12,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-15T14:35:02.000+00:00",
        "updateTime": "2023-09-19T05:12:12.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章",
          "NodeJS"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1702121864593272834",
        "title": "JavaScript-ES6",
        "description": "ES6新特性",
        "content": "# ES6 总结\n# let,const\n## let\n1. let声明的变量只在let命令所在的代码块内有效\n2. 避免变量提升\n3. 暂时性死区\n4. 不允许重复声明\n5. 块级作用域\n6. for循环的计数器，就很合适使用let命令\n7. 全局对象的属性\n## const\n1. const声明一个只读的常量。一旦声明，常量的值就不能改变\n2. const一旦声明变量，就必须立即初始化，不能留到以后赋值\n3. const的作用域与let命令相同：只在声明所在的块级作用域内有效\n4. const声明的常量，也与let一样不可重复声明\n5. 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心\n\n# 模板字符串\n## 基本用法\n```javascript\nlet name = 'Bob', time = 'today';\n let a = `Hello ${name}, how are you ${time}?`\nconsole.log(a);\n```\n# 解构语法\n\n## 解构数组\n```javascript\nlet [a,b,c] = [1,2,3];\nconsole.log(a,b,c);\n````\n## 解构字符串\n```javascript\nconst [a,b,c,d,e] = 'hello';\nconsole.log(a,b,c,d,e);\n```\n\n## 解构对象\n```javascript\nlet {foo,bar} = {foo:'aaa',bar:'bbb'};\nconsole.log(foo,bar);\n```\n## 解构参数\n```javascript\nfunction add([x,y]){\n    return x+y;\n}\nconsole.log(add([1,2]));\n```\n# 对象简化\n```javascript\n//未简化\nlet name = 'Bob', time = 'today';\nlet obj = {\n    name:name,\n    time:time\n}\nconsole.log(obj);\n//简化\nlet name = 'Bob', time = 'today';\nlet obj = {\n    name,\n    time\n}\nconsole.log(obj);\n```\n# 参数默认值\n```javascript\n// 基本用法\nfunction log(x,y='World'){\n    console.log(x,y);\n}\nlog('Hello');\nlog('Hello','China');\nlog('Hello','');\n\n// 函数参数是对象时设置默认值,数组是[]，对象是{}\nfunction Point({x=0,y=0} = {}){\n    this.x = x;\n    this.y = y;\n}\nlet p = new Point();\nconsole.log(p);\n```\n\n## ...Rest\n```javascript\nfunction add(...values){\n    let sum = 0;\n    for(var val of values){\n        sum += val;\n    }\n    return sum;\n}\nconsole.log(add(2,5,3));\n```\n## 扩展运算符\n```javascript\n// 扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列\nconsole.log(...[1,2,3]);\nconsole.log(1,...[2,3,4],5);\n// 扩展运算符与正常的函数参数可以结合使用，非常灵活\nfunction f(v,w,x,y,z){\n    console.log(v,w,x,y,z);\n}\nconst args = [0,1];\nf(-1,...args,2,...[3]);\n```\n## Ajax--->promise\n```javascript\n// 传统ajax\nfunction ajax(url,successCallback,failedCallback){\n    var xmlHttp = new XMLHttpRequest();\n    xmlHttp.open('GET',url,true);\n    xmlHttp.onreadystatechange = function(){\n        if(xmlHttp.readyState == 4){\n            if(xmlHttp.status == 200){\n                successCallback(xmlHttp.responseText);\n            }else{\n                failedCallback(xmlHttp.status);\n            }\n        }\n    }\n    xmlHttp.send();\n}\nfunction success(text){\n    console.log(text);\n}\nfunction failed(status){\n    console.log(status);\n}\najax('http://localhost:8080/test.json',success,failed);\n// promise\nfunction ajax(url){\n    return new Promise(function(resolve,reject){\n        var xmlHttp = new XMLHttpRequest();\n        xmlHttp.open('GET',url,true);\n        xmlHttp.onreadystatechange = function(){\n            if(xmlHttp.readyState == 4){\n                if(xmlHttp.status == 200){\n                    resolve(xmlHttp.responseText);\n                }else{\n                    reject(xmlHttp.status);\n                }\n            }\n        }\n        xmlHttp.send();\n    })\n}\najax('http://localhost:8080/test.json').then(function(text){\n    console.log(text);\n},function(status){\n    console.log(status);\n})\n```\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 23,
        "thumbNum": 0,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-14T00:47:31.000+00:00",
        "updateTime": "2023-09-19T01:25:38.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章",
          "Javascript"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1701432619528462338",
        "title": "JavaScript-DOM解析",
        "description": null,
        "content": "# JavaScript-DOM 操作\n\n\n## 获取属性\n在 JavaScript 中，你可以使用以下方式获取元素的属性：\n\n- `getElementById()`：通过元素的 id 获取 DOM 元素。\n- `getElementsByClassName()`：通过元素的类名获取 DOM 元素。\n- `getElementsByTagName()`：通过元素的标签名获取 DOM 元素。\n- `querySelector()`：通过 CSS 选择器获取 DOM 元素。\n- `querySelectorAll()`：通过 CSS 选择器获取所有匹配的 DOM 元素。\n\n## 操作属性\nCURD 示例\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>属性操作</title>\n    <script>\n        window.onload = function () {\n            let element = document.querySelector(\"#box\");\n            // 标准属性\n            //获取id 属性的值\n            console.log(element.id);\n            console.log(element['id']);\n            console.log(element.getAttribute('id'));\n\n            //设置id 属性的值\n            element.id = 'box2';\n            element['id'] = 'box3';\n            element.setAttribute('id', 'box4');\n\n\n            console.log('<------------------------>');\n            //自定义属性\n            // element.xxx ='xxx';\n            // element['xxx'] = 'xxx';\n            // 自定义属性的值只能通过setAttribute() 方法设置属性\n            element.setAttribute(\"xxx\", 'xxx')\n            // 自定义属性的值只能通过getAttribute() 方法获取属性\n            element.getAttribute('xxx');\n\n\n            // 操作特殊属性\n            // 1. class 属性 需要使用className, 因为class 是关键字\n            //console.log(element.class);\n            console.log(element.className);\n           // console.log(element['class']);\n            console.log(element['className']);\n            console.log(element.getAttribute('class'));\n            // 2.style 属性\n            console.log(element.style);\n            console.log(element.style.width);\n            console.log(element.style.height);\n            console.log(element.style[\"background-color\"]);\n            console.log(element.style.backgroundColor);\n            element.style.width = '300px';\n            element.style.height = '300px';\n            element.style.backgroundColor = 'blue';\n            element.style.backgroundImage = 'url(../img/1.jpg)';\n\n            // 属性名和属性值相同\n            // 有这个属性就是true, 没有就是false\n            let element1 = document.querySelector('[type=checkbox]');\n            console.log(element1.checked);\n            element1.checked = true;  // 选中\n        }\n\n    </script>\n\n</head>\n<body>\n<div id=\"box\" class=\"box\" style=\"width: 200px;height: 200px;background-color: pink\"></div>\n<input type=\"checkbox\" >\n</body>\n</html>\n```\n## NOde获取\n\n```js\n        element.firstChild; // 第一个子节点\n        element.lastChild; // 最后一个子节点\n        element.childNodes; // 所有子节点\n        element.previousSibling; // 上一个兄弟节点\n        element.nextSibling; // 下一个兄弟节点\n        element.parentNode; // 父节点\n        element.parentNode.parentNode.parentNode  //document\n```\n## Node 操作\n\nNode 操作是 JavaScript DOM 操作中的一个关键部分，它涉及到在文档对象模型中操作和管理 HTML 元素和节点。下面详细讨论 Node 操作的一些重要概念和方法：\n\n\n1. 获取元素节点\n\n   通过 getElementById 获取元素\n```javascript\nconst element = document.getElementById(\"myElement\");\n```\n通过 querySelector 获取元素\n```javascript\nconst element = document.querySelector(\".myClass\");\n```\n通过 getElementsByTagName 获取元素集合\n```javascript\nconst elements = document.getElementsByTagName(\"div\");\n```\n2. 获取文本节点\n获取元素的文本内容\n```javascript\nconst element = document.getElementById(\"myElement\");\nconst textContent = element.textContent;\n```\n3. 创建新节点\n创建元素节点\n```javascript\nconst newElement = document.createElement(\"div\");\n```\n创建文本节点\n```javascript\nconst newText = document.createTextNode(\"Hello, World!\");\n```\n4. 添加、移动和删除节点\n添加子节点\n```javascript\nconst parent = document.getElementById(\"parentElement\");\nconst child = document.getElementById(\"childElement\");\nparent.appendChild(child); // 将子节点添加到父节点中\n```\n移动节点\n```javascript\nconst target = document.getElementById(\"targetElement\");\nconst destination = document.getElementById(\"destinationElement\");\ndestination.appendChild(target); // 移动节点到新的父节点中\n```\n删除节点\n```javascript\nconst elementToRemove = document.getElementById(\"elementToRemove\");\nelementToRemove.parentNode.removeChild(elementToRemove); // 从父节点中移除节点\n```\n5. 复制节点\n复制节点\n```javascript\nconst original = document.getElementById(\"originalElement\");\nconst copy = original.cloneNode(true); // true 表示复制节点的子节点\n```\n6. 替换节点\n替换节点\n```javascript\nconst existing = document.getElementById(\"existingElement\");\nconst replacement = document.getElementById(\"replacementElement\");\nexisting.parentNode.replaceChild(replacement, existing);\n```\n7. 遍历节点\n遍历子节点\n```javascript\nconst parent = document.getElementById(\"parentElement\");\nconst children = parent.childNodes;\nfor (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    // 进行操作...\n}\n```\nNode 操作允许你在 HTML 文档中创建、获取、移动和删除节点，以及遍历节点树。\n\n## 事件处理\n\n\n事件处理是 JavaScript DOM 操作中的一个重要方面，它允许你在 HTML 元素上注册事件监听器，以便在特定事件发生时执行相应的操作。以下是有关事件处理的详细内容：\n\n1. 注册事件监听器\n使用 addEventListener 注册事件监听器\n```javascript\nconst element = document.getElementById(\"myElement\");\n\nelement.addEventListener(\"click\", function() {\n    // 在点击事件发生时执行的代码\n});\n```\n2. 常见事件类型\n以下是一些常见的事件类型：\n```js\n\"click\"：当元素被点击时触发。\n\"mouseover\"：当鼠标指针移动到元素上方时触发。\n\"mouseout\"：当鼠标指针从元素上方移开时触发。\n\"keydown\"：当键盘按键被按下时触发。\n\"keyup\"：当键盘按键被释放时触发。\n\"submit\"：当表单提交时触发。\n\"change\"：当表单元素的值发生改变时触发（适用于输入框、下拉列表等）。\n```\n3. 事件对象\n事件监听器的回调函数可以接收一个事件对象，该对象包含与事件相关的信息。例如：\n\n```javascript\nelement.addEventListener(\"click\", function(event) {\n    console.log(event.type); // 输出事件类型，如 \"click\"\n    console.log(event.target); // 输出触发事件的元素\n});\n```\n4. 阻止默认行为\n有时，你可能希望阻止事件的默认行为。例如，阻止表单提交或超链接跳转：\n\n```javascript\nelement.addEventListener(\"click\", function(event) {\n    event.preventDefault(); // 阻止默认行为\n});\n```\n5. 事件冒泡\n事件冒泡是指事件从最具体的元素（例如按钮）向最不具体的元素（例如文档）传播的过程。你可以使用 stopPropagation 方法停止事件冒泡：\n\n```javascript\nelement.addEventListener(\"click\", function(event) {\n    event.stopPropagation(); // 阻止事件冒泡\n});\n```\n6. 事件委托\n事件委托是一种将事件监听器添加到父元素而不是每个子元素的技术。这可以提高性能，并且对于动态生成的子元素非常有用。\n\n```javascript\nconst parent = document.getElementById(\"parentElement\");\n\nparent.addEventListener(\"click\", function(event) {\n    if (event.target.tagName === \"BUTTON\") {\n        // 在按钮被点击时执行操作\n    }\n});\n```\n7. 移除事件监听器\n要移除事件监听器，使用 removeEventListener 方法：\n\n```javascript\nconst element = document.getElementById(\"myElement\");\n\nfunction myHandler() {\n    // 事件处理逻辑\n}\n\nelement.addEventListener(\"click\", myHandler);\n\n// 在稍后的某个时刻移除监听器\nelement.removeEventListener(\"click\", myHandler);\n```\n\n\n\n\n\n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 14,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-12T03:08:42.000+00:00",
        "updateTime": "2023-09-14T09:47:07.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1700845181969997825",
        "title": "前端学习之JavaScript-day01",
        "description": null,
        "content": "1. js 代码编写的位置 :\n    1. 内部js代码\n    2. 外部js代码\n    3. 行内js代码\n   4. 三种方式的优先级： 行内 > 内部 > 外部\n\n2. js变量的定义和使用\n    \n        1. var\n        2. let\n        3. const\n        4. 变量的使用： 变量名\n3. js数据类型\n    1. 基本数据类型\n        1. number\n        2. string\n        3. boolean\n        4. undefined\n        5. null\n    2. 引用数据类型\n        1. object\n        2. array\n        3. function\n        4. date\n        5. 正则表达式\n        6. Math\n        7. ...\n       8. 以上都是对象\n4. 运算符\n\n        1. ==  ===\n\n`==` 会自动转换数据类型，再比较值是否相等；\n\n`===` 不会自动转换数据类型,先比较数据类型，再比较值是否相等；\n\n       2. &&   ||\n    \n`&&` 逻辑与，两边都为真，结果为真，否则为假；\n\n总体为假,返回第一个的值；总体为真，返回第二个的值；\n   \n`||` 逻辑或，两边都为假，结果为假，否则为真；\n\n总体为真,返回第一个的值；总体为假，返回最后一个的值；\n    \n5. 函数的定义和调用(**重中之重**)\n\n  1. 普通函数定义\n   ```js\n    function 函数名(形式参数1, 形式参数2, ...) {\n         函数体;\n    }\n```\n2. 匿名函数的定义\n    ```js\n    var 函数名 = function(形式参数1, 形式参数2, ...) {\n         函数体;\n    }\n    \n    //立即调用函数\n    (function(形式参数1, 形式参数2, ...) {\n         函数体;\n    })(实际参数1, 实际参数2, ...);\n    ```\n    3. 箭头函数的定义\n    \n    ```javascript\n    var 函数名 = (形式参数1, 形式参数2, ...) => {\n         函数体;\n    }\n    ```\n    \n    4. 函数调用： 函数名(实际参数);\n    ```javascript\n    function 函数名(形式参数1, 形式参数2, ...) {\n         函数体;\n    }\n    函数名(实际参数1, 实际参数2, ...);\n    ```\n    \n    5. 理解到匿名函数的使用(难点)\n    ```javascript\n    // 普通使用\n    var 函数名 = function(形式参数1, 形式参数2, ...) {\n         函数体;\n    }\n    函数名(实际参数1, 实际参数2, ...);\n    \n    //函数作为参数使用\n    function fun() {\n         函数体;\n    }\n    \n    function fun2(fun) {\n         函数体;\n    }\n    ```\n    \n\n6. 构造函数/创建对象/对象的成员访问/字面式创建对象\n```javascript\n//构造函数\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n    this.say = function() {\n        console.log(\"我是\" + this.name + \",今年\" + this.age + \"岁了\");\n    }\n}\n// 创建对象\n// 构造函数的调用方式\nvar p1 = new Person(\"张三\", 18);\np1.say();\n// 字面量\nvar p2 = {\n    name: \"李四\",\n    age: 20,\n    say: function() {\n        console.log(\"我是\" + this.name + \",今年\" + this.age + \"岁了\");\n    }\n}\n// 对象的成员访问\np2.name;\np2.age;\n```\n\n6. 数组的定义(简写方式)\n```javascript\n// 定义数组\nvar arr = [1, 2, 3, 4, 5];\n```\n\n7. 数组的遍历(普通)\n```javascript\n// for i 循环\nfor (var i = 0; i < arr.length; i++) {\n    console.log(arr[i]);\n}\n// for in 循环\nfor (var i in arr) {\n    console.log(arr[i]);\n}\n// forEach 循环\narr.forEach(function(value, index, array) {\n    console.log(value);\n});\n\n// map 循环\narr.map(function(value, index, array) {\n    console.log(value);\n});\n```\n\n9. 需要理解 forEach / map，从而理解匿名函数在开发中的使用\n```javascript\n// forEach 循环  ---->获取数组中的每一个元素\n// map 循环  ---->获取数组中的每一个元素,可以整体修改数组中的元素,并返回一个新的数组\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 19,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-09-10T12:14:26.000+00:00",
        "updateTime": "2023-09-19T02:08:47.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it\uD83D\uDE23\uD83D\uDE23",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 7,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-09-20T00:47:27.000+00:00"
        },
        "tags": [
          "文章",
          "Javascript",
          "前端",
          "Java",
          "后端",
          "学习路线"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "167",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "21"
  },
  "message": "ok"
}